'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  const callback = this.async();
  load(this).then(r => callback(null, r), e => callback(e, null));
};

var _util = require('util');

var _child_process = require('child_process');

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _loaderUtils = require('loader-utils');

var _loaderUtils2 = _interopRequireDefault(_loaderUtils);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function BuildError(message) {
  Error.captureStackTrace(this, this.constructor);
  this.name = this.constructor.name;
  this.message = message;
}

(0, _util.inherits)(BuildError, Error);

const execAsync = (0, _util.promisify)(_child_process.exec);

const findSrcDir = (() => {
  var _ref = _asyncToGenerator(function* (childPath) {
    let candidate = childPath;

    while (candidate !== _path2.default.parse(candidate).root) {
      const maybeCargoFile = _path2.default.join(candidate, 'Cargo.toml');
      if (yield _fsExtra2.default.pathExists(maybeCargoFile)) {
        return candidate;
      }
      candidate = _path2.default.dirname(candidate);
    }

    return null;
  });

  return function findSrcDir(_x) {
    return _ref.apply(this, arguments);
  };
})();

const cargoCommand = (target, release, subcmd = []) => {
  const cmd = ['cargo', ...subcmd, 'build', '--message-format=json', '--target=' + target];

  if (release) {
    cmd.push('--release');
  }

  return cmd.join(' ');
};

const DEFAULT_OPTIONS = {
  release: false,
  gc: false,
  target: 'wasm32-unknown-unknown',
  cargoWeb: false,
  name: undefined,
  regExp: undefined,
  wasmBindgen: false,
  wasm2es6js: false,
  typescript: false
};

const execPermissive = (() => {
  var _ref2 = _asyncToGenerator(function* (cmd, srcDir) {
    try {
      let options = { cwd: srcDir, encoding: 'utf-8', maxBuffer: 2 * 1024 * 1024 * 1024 };
      return yield execAsync(cmd, options);
    } catch (e) {
      return e;
    }
  });

  return function execPermissive(_x2, _x3) {
    return _ref2.apply(this, arguments);
  };
})();

const loadWasmBindgen = (() => {
  var _ref3 = _asyncToGenerator(function* (self, { release, target, wasm2es6js, typescript }, srcDir) {
    const cmd = cargoCommand(target, release);
    const result = yield execPermissive(cmd, srcDir);

    const { wasmFile } = yield handleCargo(self, result);

    if (!wasmFile) {
      throw new BuildError('No wasm file produced as build output');
    }
    const suffixlessPath = wasmFile.slice(0, -'.wasm'.length);
    const moduleDir = _path2.default.dirname(wasmFile);

    yield execAsync(`wasm-bindgen ${wasmFile} --out-dir ${moduleDir}${typescript ? ' --typescript --nodejs' : ''}`);

    if (wasm2es6js) {
      const glueWasmPath = suffixlessPath + '_wasm.wasm';
      const glueJsPath = suffixlessPath + '_wasm.js';

      yield execAsync(`wasm2es6js ${glueWasmPath} -o ${glueJsPath} --base64`);
    }

    if (typescript) {
      const tsdPath = suffixlessPath + '.d.ts';
      const jsPath = suffixlessPath + '.js';
      const wasmPath = suffixlessPath + (wasm2es6js ? '_wasm.js' : '_wasm.wasm');

      const jsRequest = _loaderUtils2.default.stringifyRequest(self, jsPath);
      const tsdRequest = _loaderUtils2.default.stringifyRequest(self, tsdPath);
      const wasmRequest = _loaderUtils2.default.stringifyRequest(self, wasmPath);

      let contents = `
/// <reference path=${tsdRequest} />
export * from ${jsRequest};
`;
      if (wasm2es6js) {
        contents += `
import * as wasm from ${wasmRequest};
export const wasmBooted: Promise<boolean> = wasm.booted
`;
      }
      return contents;
    } else {
      let contents = yield _fsExtra2.default.readFile(suffixlessPath + '.js', 'utf-8');
      if (wasm2es6js) {
        contents += 'export const wasmBooted = wasm.booted\n';
      }
      const wasmImport = suffixlessPath + '_wasm';
      const includeRequest = _loaderUtils2.default.stringifyRequest(self, wasmImport);

      contents = contents.replace(`from './${_path2.default.basename(wasmImport)}'`, `from ${includeRequest}`);
      return contents;
    }
  });

  return function loadWasmBindgen(_x4, _x5, _x6) {
    return _ref3.apply(this, arguments);
  };
})();

const loadCargoWeb = (() => {
  var _ref4 = _asyncToGenerator(function* (self, { release, name, target, regExp }, srcDir) {
    const cmd = cargoCommand(target, release, ['web']);
    const result = yield execPermissive(cmd, srcDir);

    const { wasmFile, jsFile } = yield handleCargo(self, result);

    if (!wasmFile) {
      throw new BuildError('No wasm file produced as build output');
    }
    if (!jsFile) {
      throw new BuildError('No js file produced as build output');
    }

    const jsData = yield _fsExtra2.default.readFile(jsFile, 'utf-8');
    const wasmData = yield _fsExtra2.default.readFile(wasmFile);

    const context = self.context || self.options && self.options.context;
    const wasmOutFileName = _loaderUtils2.default.interpolateName(self, name, {
      context, content: wasmData, regExp
    });

    self.emitFile(wasmOutFileName, wasmData);

    // Ugly way to do replaceAll... would be great to have some way to create a custom template here
    return jsData.split(`fetch( ${JSON.stringify(_path2.default.basename(wasmFile))} )`).join(`fetch(__webpack_public_path__ + ${JSON.stringify(wasmOutFileName)})`).split(JSON.stringify(_path2.default.basename(wasmFile))).join(JSON.stringify(wasmOutFileName));
  });

  return function loadCargoWeb(_x7, _x8, _x9) {
    return _ref4.apply(this, arguments);
  };
})();

const loadRaw = (() => {
  var _ref5 = _asyncToGenerator(function* (self, { release, gc, target }, srcDir) {
    const cmd = cargoCommand(target, release);
    const result = yield execPermissive(cmd, srcDir);

    let { wasmFile } = yield handleCargo(self, result);

    if (!wasmFile) {
      throw new BuildError('No wasm file produced as build output');
    }

    if (gc) {
      let gcWasmFile = wasmFile.substr(0, wasmFile.length - '.wasm'.length) + '.gc.wasm';
      yield execAsync(`wasm-gc ${wasmFile} ${gcWasmFile}`);
      wasmFile = gcWasmFile;
    }

    return yield _fsExtra2.default.readFile(wasmFile);
  });

  return function loadRaw(_x10, _x11, _x12) {
    return _ref5.apply(this, arguments);
  };
})();

const handleCargo = (() => {
  var _ref6 = _asyncToGenerator(function* (self, result) {
    let wasmFile;
    let jsFile;
    let hasError = false;
    outer: for (let line of result.stdout.split('\n')) {
      if (/^\s*$/.test(line)) {
        continue;
      }
      const data = JSON.parse(line);
      switch (data.reason) {
        case 'compiler-message':
          switch (data.message.level) {
            case 'warning':
              self.emitWarning(new Error(data.message.rendered));
              break;
            case 'error':
              self.emitError(new Error(data.message.rendered));
              hasError = true;
              break;
          }
          break;
        case 'compiler-artifact':
          if (!wasmFile) {
            wasmFile = data.filenames.find(function (p) {
              return p.endsWith('.wasm');
            });
          }
          if (!jsFile) {
            jsFile = data.filenames.find(function (p) {
              return p.endsWith('.js');
            });
          }
          if (wasmFile) {
            break outer;
          }
          break;
      }
    }

    if (hasError) {
      throw new BuildError('Cargo build failed');
    }

    const depFile = wasmFile.slice(0, -'.wasm'.length) + '.d';
    const depContents = yield _fsExtra2.default.readFile(depFile, 'utf-8');
    for (let line of depContents.split('\n')) {
      if (line.startsWith(wasmFile) || jsFile && line.startsWith(jsFile)) {
        for (let dep of line.split(/:\s+/)[1].split(/\s+/)) {
          self.addDependency(dep);
        }
      }
    }

    return { wasmFile, jsFile };
  });

  return function handleCargo(_x13, _x14) {
    return _ref6.apply(this, arguments);
  };
})();

const load = (() => {
  var _ref7 = _asyncToGenerator(function* (self) {
    const srcDir = yield findSrcDir(self.resourcePath);
    if (!srcDir) {
      throw new BuildError('No Cargo.toml file found in any parent directory.');
    }
    self.addDependency(_path2.default.join(srcDir, 'Cargo.toml'));

    const opts = Object.assign({}, DEFAULT_OPTIONS, _loaderUtils2.default.getOptions(self));
    const cargoWeb = opts.cargoWeb;
    const wasmBindgen = opts.wasmBindgen;

    if (wasmBindgen || cargoWeb) {
      try {
        if (wasmBindgen) {
          return yield loadWasmBindgen(self, opts, srcDir);
        } else if (cargoWeb) {
          return yield loadCargoWeb(self, opts, srcDir);
        } else {
          throw new Error("Unreachable code");
        }
      } catch (e) {
        if (e instanceof BuildError) {
          self.emitError(e);
          return `throw new Error(${JSON.stringify(e.message)});\n`;
        } else {
          throw e;
        }
      }
    } else {
      return yield loadRaw(self, opts, srcDir);
    }
  });

  return function load(_x15) {
    return _ref7.apply(this, arguments);
  };
})();

;