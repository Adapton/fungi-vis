type Vec = (#T.user(Vec))
// Seq[X,Y]:
// Refinement type for a nominal, level-tree data structure,
// ...      with (unallocated) names in X
// ... and (allocated) pointer names in Y
//
type Seq = (
    // Ordering here is important: The recursive type name T
    // should refer to the type that is parameteric in X and
    // Y; the version below has a fixed choice for X and Y for
    // all recursive unrollings.
    // (See my other version of type Seq, for filter, below).
    rec Seq. #X.#Y.#T.
    (+ Vec T
     + (exists (X1,X2,X3)   :NmSet | (X1%X2%X3=X).
        exists (Y1,Y2,Y3,Y4):NmSet | (Y1%Y2%Y3%Y4=Y).
        x Nm[X1] x Nat
        // Seq vs T ??
        x Ref[Y1](Seq[X2][Y2] T)
        // Seq vs T ??
        x Ref[Y3](Seq[X3][Y4] T))
    )
)
let nums:(Seq[X][Y] Nat) = { unimplemented }        
let vec_max:(Thk[0] Vec Nat -> (F Nat |> {0;0}) |> {0;0}) = {
    unimplemented
}
let rec max:(
    Thk[0] foralli (X,Y):NmSet.
        Seq[X][Y] Nat -> (F Nat |>
            {(#x.{x,@1} % {x,@2}) X; 0})
        |> {0;0}
) = {
    #seq. unroll seq seq. match seq {
        vec => { {force vec_max} vec }
        bin => {
            let (n,_x,l,r) = {ret bin}
            //
            // Left recursion:
            // sugar version #1 (most sugared)
            let (unused, ml) = { memo{n,(@1)}{ {force max} {!l} } }
            // sugar version #2 (name construction first; then memo construct)
            let n1 = {n,(@1)}
            let (unused, ml) = { memo(n1){ {force max} {!l} } }
            //
            // Right recursion:
            // non-sugar version (all sub-expressions are explicit)
            let nf = { ret nmfn #n.#v.n,v }
            let n2 = { [nf] n (@2) }
            let mr = {
                let t = { thk n2
                    let rv = {get r}
                    {force max} rv
                }
                {force t}
            }
            if { mr < ml } {ret ml} else {ret mr}
        }
    }
}
{force max} nums

// always Nats
type Vec = (user(Vec))

let vec_filter:( Thk[0]
    Vec Nat -> (
        (Thk[0] Nat -> (F Bool |> {0;0}) |> {0;0}) ->
        (F Vec Nat |> {0;0}) |> {0;0}
    ) |> {0;0}
) = {
    unimplemented
}

let vec_map:( Thk[0]
    Vec Nat -> (
        (Thk[0] Nat -> (F Nat |> {0;0}) |> {0;0}) ->
        (F Vec Nat |> {0;0}) |> {0;0}
    ) |> {0;0}
) = {
    unimplemented
}

// Syntax for idiomatic recursive types
// (avoid double-naming, as with `let rec`)?
//
//   type rec T = (A)  ==>  type T = (rec T. A)
//
// Using RHS below (not LHS yet, but maybe?)
//
type Seq = (
    rec Seq.#X.#Y.
    (+ Vec 
     + (exists (X1,X2,X3)   :NmSet | (X1%X2%X3=X).
        exists (Y1,Y2,Y3,Y4):NmSet | (Y1%Y2%Y3%Y4=Y).
        x Nm[X1] x Nat
        x Ref[Y1](Seq[X2][Y2])
        x Ref[Y3](Seq[X3][Y4]))
    )
)
let nums:(Seq[X][Y] Nat) = { unimplemented }

let rec max:(
    Thk[0] foralli (X,Y):NmSet.
        Seq[X][Y] Nat -> (F Nat |>
            {(#x.{x,@1} % {x,@2}) X; 0})
        |> {0;0}
) = {
    #seq. unroll seq seq. match seq {
        vec => { {force vec_max} vec }
        bin => {
            let (n,_x,l,r) = {ret bin}
            let (unused, ml) = { memo{n,(@1)}{ {force max} {!l} } }
            let (unused, mr) = { memo{n,(@2)}{ {force max} {!r} } }
            if { mr < ml } {ret ml} else {ret mr}
        }
    }
}

let rec filter:(
    Thk[0] foralli (X,Y):NmSet.
        (Seq[X][Y] Nat) -> (
            (Thk[0] Nat -> (F Bool |> {0;0}) |> {0;0}) ->
            (F Nat |> {(#x.{x,@1} % {x,@2}) X; 0})
            |> {0;0}
        ) |> {0;0}
) = {
    #seq. #f. unroll match seq {
        vec => { {force vec_filter} f vec }
        bin => {
            let (n,lev,l,r) = {ret bin}
            let (rsl, sl) = { memo{n,(@1)}{ {force filter} f {!l} } }
            let (rsr, sr) = { memo{n,(@2)}{ {force filter} f {!r} } }
            // if left is empty, return the right
            if {{force is_empty} sl} { ret sr }
            else { // if right is empty, return the left
                if {{force is_empty} sr} { ret sl }
                else {
                    // neither are empty; construct SeqBin node:
                    ret roll inj2 (n,lev,rsl,rsr)
                }
            }
        }
    }
}

let rec map:(
    Thk[0] foralli (X,Y):NmSet.
        (Seq[X][Y] Nat) -> (
            (Thk[0] Nat -> (F Nat |> {0;0}) |> {0;0}) ->
            (F Nat |> {(#x.{x,@1} % {x,@2}) X; 0})
            |> {0;0}
        ) |> {0;0}
) = {
    #seq. #f. unroll match seq {
        vec => { {force vec_map } f vec }
        bin => {
            let (n,lev,l,r) = {ret bin}
            let (rsl, sl) = { memo{n,(@1)}{ {force map} f {!l} } }
            let (rsr, sr) = { memo{n,(@2)}{ {force map} f {!r} } }
            ret roll inj2 (n,lev,rsl,rsr)
        }
    }
}

{force max} nums