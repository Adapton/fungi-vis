type Vec = (forallt T:type.user(Vec))
// Seq[X,Y]:
// Refinement type for a nominal, level-tree data structure,
// ...      with (unallocated) names in X
// ... and (allocated) pointer names in Y
//
type Seq = (
    rec Seq. foralli (X,Y):NmSet. forallt T:type.
    (+ Vec T
     + (exists (X1,X2,X3)   :NmSet | (X1%X2%X3=X).
        exists (Y1,Y2,Y3,Y4):NmSet | (Y1%Y2%Y3%Y4=Y).
        x Nm[X1] x Nat
        // Seq vs T ??
        x Ref[Y1](Seq[X2][Y2] T)
        // Seq vs T ??
        x Ref[Y3](Seq[X3][Y4] T))
    )
)
let nums:(Seq[X][Y] Nat) = { unimplemented }        
let vec_max:(Thk[0] 0 Vec Nat -> 0 F Nat) = {
    unimplemented
}
let rec max:(
    Thk[0] foralli (X,Y):NmSet.
        0 Seq[X][Y] Nat ->
        {(#x:Nm.{x,@1} % {x,@2}) X; 0} F Nat
) = {
    #seq. unroll seq seq. match seq {
        vec => { {force vec_max} vec }
        bin => {
            let (n,_x,l,r) = {ret bin}
            //
            // Left recursion:
            // sugar version #1 (most sugared)
            let (unused, ml) = { memo{n,(@1)}{ {force max} {!l} } }
            // sugar version #2 (name construction first; then memo construct)
            let n1 = {n,(@1)}
            let (unused, ml) = { memo(n1){ {force max} {!l} } }
            //
            // Right recursion:
            // non-sugar version (all sub-expressions are explicit)
            let nf = { ret nmfn #n:Nm.#v:Nm.n,v }
            let n2 = { [nf] n (@2) }
            let mr = {
                let t = { thk n2
                    let rv = {get r}
                    {force max} rv
                }
                {force t}
            }
            if { mr < ml } {ret ml} else {ret mr}
        }
    }
}
{force max} nums